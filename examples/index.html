<!DOCTYPE html>
<html>
<head>
    <title></title>

    <script type="text/javascript" src="../build/three.js"></script>
    <script type="text/javascript" src="./js/libs/stats.min.js"></script>
    <script type="text/javascript" src="./js/fps-lib/FPSControls.js"></script>
    <script type="text/javascript" src="./js/fps-lib/pointerlock.js"></script>

    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="blocker">

        <div id="instructions">
            <span style="font-size:40px">Click to play</span>
            <br />
            (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
        </div>

    </div>
    <script type="text/javascript">
        
        function startGame(){

            var objects=[];
            var bboxes=[];
            var selectableObjects=[];
            var outlines=[];
            var boundingBoxesActive = false;
            var camera;
            var scene;
            var loaded;
            var controls;
            var objectLoader;
            var raycaster;
            var overlayinit=false;
            var mouse=new THREE.Vector2(), INTERSECTED;
            var overlaydesk;
            init();

            function init(){
                eventHandlers();
                loaded=false;
                
                camera = new THREE.PerspectiveCamera(80,window.innerWidth/ window.innerHeight, 1 , 9000);

                scene = new THREE.Scene();

                renderer = new THREE.WebGLRenderer();

                var ambient = new THREE.AmbientLight( 0x444444 );
                scene.add( ambient );
                // instantiate a loader
                var directionalLight = new THREE.DirectionalLight( 0xffeedd );
                directionalLight.position.set( 0, 0, 1 ).normalize();
                scene.add( directionalLight );


                objectLoader = new THREE.ObjectLoader().load("models/desk.json",function(obj){
                         obj.position.x=-50;
                         obj.scale.set(3,3,3);
                        objects.push(obj);

                        controls = new THREE.PointerLockControls( camera, 50, 15, true, objects );
                        scene.add( controls.getPlayer() );
                        scene.add(obj);
                        loaded=true;   

                        //boundingboxhelper for the object
                        var bbox = new THREE.BoundingBoxHelper(obj);
                        bbox.update();
                        bbox.visible=boundingBoxesActive;
                        bboxes.push(bbox);
                        scene.add(bbox);
                });

                        // Floor
                // var floorHeight = 7000;
                // geometry = new THREE.SphereGeometry(floorHeight, 10, 6, 0, (Math.PI * 2), 0, 0.8);
                // geometry.applyMatrix( new THREE.Matrix4().makeTranslation(0, -floorHeight, 0) );
                var geometry = new THREE.BoxGeometry(7000,1,7000); //change floor to flat(useing box)

                var material = new THREE.MeshBasicMaterial();

                floorMesh = new THREE.Mesh( geometry, material );
                objects.push( floorMesh );
                scene.add( floorMesh  );



                //overlay imported object using mesh, but set it to invisible
                var boxgeometry = new THREE.BoxGeometry( 8, 50, 6 );
                var material = new THREE.MeshBasicMaterial({color:0x00ffff,visible:true});
                var mesh = new THREE.Mesh( boxgeometry, material );
                mesh.position.x=-50;
                mesh.name="box biru";
                mesh.bcolor = 0x00ffff;
                mesh.outlineid = 0;
                objects.push(mesh);
                selectableObjects.push(mesh); //push juka object = selectable
                scene.add( mesh );
                overlaydesk=mesh;
                //OUTLINE MESH UNTUK SELECTABLE OBJECT
                var outlineMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.BackSide } );
                var outlineMesh = new THREE.Mesh( boxgeometry, outlineMaterial );
                outlineMesh.position.x=-50
                outlineMesh.scale.multiplyScalar(1.05);
                outlineMesh.material.transparent=true;
                outlineMesh.material.opacity = 0;
                outlines.push(outlineMesh);
                //outlineMesh.visible=false;
                scene.add( outlineMesh );


                // var planegeo = new THREE.PlaneGeometry(10,10,1);
                // var material = new THREE.MeshBasicMaterial({color:0xff00ff,visible:true});
                // var planemesh = new THREE.Mesh( planegeo, material );
                // planemesh.position.y=10;
                // objects.push(planemesh);
                // scene.add( planemesh );              


               toggleBoundingBoxes = function(bool) {
                  if(bool){
                    var state = !boundingBoxesActive;
                    for (i in bboxes) {
                        bboxes[i].visible = state;
                    }
                    boundingBoxesActive = state;
                  }
                }

                var i;
                var def=5;
                var iter=def;

                var planegeo = new THREE.PlaneGeometry(10,10,1);
                var material = new THREE.MeshBasicMaterial({color:0x0000ff,visible:true});
                
                for(i=0; i<5; i++) {
                    mesh = new THREE.Mesh( planegeo, material );
                    mesh.position.set(iter,0,-200);
                    mesh.scale.x=70;
                    mesh.scale.y=10;
                    objects.push(mesh);
                    scene.add( mesh );
                    iter-=1;                    
                }

                iter=def;

                for(i=0; i<5; i++) {
                    mesh = new THREE.Mesh( planegeo, material );
                    mesh.position.set(-100,iter,-100);
                    mesh.rotation.set(0, Math.PI / 2, 0);
                    mesh.scale.x=70;
                    mesh.scale.y=10;
                    objects.push(mesh);
                    scene.add( mesh );
                    iter-=1;                    
                }

                iter=0;

                for(i=0; i<5; i++) {
                    mesh = new THREE.Mesh( planegeo, material );
                    mesh.position.set(iter,0,200);
                    mesh.rotation.set(0, Math.PI, 0);
                    mesh.scale.x=70;
                    mesh.scale.y=10;
                    objects.push(mesh);
                    scene.add( mesh );
                    iter+=1;                    
                }

                iter=0;

                for(i=0; i<5; i++) {
                    mesh = new THREE.Mesh( planegeo, material );
                    mesh.position.set(300,iter,100);
                    mesh.rotation.set(0, - Math.PI / 2, 0);
                    mesh.scale.x=70;
                    mesh.scale.y=10;
                    objects.push(mesh);
                    scene.add( mesh );
                    iter+=1;                    
                }



                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setClearColor( 0x000000 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );
                raycaster= new THREE.Raycaster();
                raycaster.far=15;
                console.log(raycaster);
                render();
            }



            function render(){
                renderer.render(scene,camera);
                if(loaded){
                    controls.updateControls();
                    if(!overlayinit){
                        ScreenOverlay(controls);
                        overlayinit=true;
                        arrow = new THREE.ArrowHelper( raycaster.ray.direction, controls.getPlayer().position, 100, Math.random() * 0xffffff );
                    }
                    scene.remove ( arrow );
                    arrow = new THREE.ArrowHelper( raycaster.ray.direction, controls.getPlayer().position, 100, Math.random() * 0xffffff );
                    scene.add( arrow );
                }
                onRaycast();
                requestAnimationFrame(render);
            }


            function onRaycast(){
                console.log(raycaster);
                raycaster.setFromCamera( mouse, camera );
                var intersects = raycaster.intersectObjects( scene.children );
                var flag=false;
                if ( intersects.length > 0 ) {

                    for (i in selectableObjects){
                        if( selectableObjects[i]== intersects[0].object ){
                            outlines[intersects[0].object.outlineid].material.opacity=1;
                            flag=true;
                        }
                    }
                    
                    // if ( overlaydesk== intersects[ 0 ].object ) {
                    //     //intersects[0].object.material.color.setHex(0x000000);
                    //     // intersects[0].object.material.opacity=1;
                    //     outlines[intersects[0].object.outlineid].material.opacity=1;
                    //     flag=true;
                    //     //alert(intersects[0].object.name + "on raycast!");
                    // }
                    
                }
                if(!flag){
                    for (i in outlines){
                        outlines[i].material.opacity=0;
                    }
                }

            }

            function interact() {
                
                raycaster.setFromCamera( mouse, camera );
                intersects = raycaster.intersectObjects( scene.children );
                // var intersects = raycaster.intersectObjects(objects, true);
                if (intersects.length > 0) {
                    for (i in selectableObjects){
                        if( selectableObjects[i]== intersects[0].object ){
                            selectedObject = intersects[0].object;
                            alert(selectedObject.name + " object selected!");
                        }
                    }
                }
            }


            function eventHandlers() {

                // Keyboard press handlers
                var onKeyDown = function ( event ) { event.preventDefault(); event.stopPropagation(); handleKeyInteraction(event.keyCode, true); };
                var onKeyUp = function ( event ) { event.preventDefault(); event.stopPropagation(); handleKeyInteraction(event.keyCode, false); };
                document.addEventListener( 'keydown', onKeyDown, false );
                document.addEventListener( 'keyup', onKeyUp, false );


                // Resize Event
                window.addEventListener( 'resize', onWindowResize, false );
            }

                // HANDLE KEY INTERACTION
                function handleKeyInteraction(keyCode, boolean) {
                    var isKeyDown = boolean;

                    switch(keyCode) {
                        case 38: // up
                        case 87: // w
                            controls.movements.forward = boolean;
                            break;

                        case 40: // down
                        case 83: // s
                            controls.movements.backward = boolean;
                            break;

                        case 37: // left
                        case 65: // a
                            controls.movements.left = boolean;
                            break;

                        case 39: // right
                        case 68: // d
                            controls.movements.right = boolean;
                            break;

                        case 32: // space
                            if (!isKeyDown) {
                                controls.jump();
                            }
                            break;

                        case 16: // shift
                            controls.walk(boolean);
                            break;

                        case 67: // crouch (CTRL + W etc destroys tab in Chrome!)
                            controls.crouch(boolean);
                            break;

                        case 66: // b
                            toggleBoundingBoxes(boolean);
                            break;

                        case 73: // i
                            interact();

                    }
                }

                

                function onWindowResize() {

                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();

                    renderer.setSize( window.innerWidth, window.innerHeight );

                }

        }

        window.onload=startGame();



    </script>
</body>
</html>