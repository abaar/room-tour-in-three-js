<!DOCTYPE html>

<html>

<head>
    <title>Example 01.04 - Materials, light and animation</title>
    <script type="text/javascript" src="../build/three.js"></script>

    <script type="text/javascript" src="./js/libs/stats.min.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    function init() {
    	

        var stats = initStats();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();

        renderer.setClearColor(new THREE.Color(0x000000));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById("WebGL-output").appendChild(renderer.domElement);

		// position and point the camera to the center of the scene
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 30;
        camera.lookAt(scene.position);

        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(200, 200, 1, 1);
        var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
       	var plane = new THREE.Mesh(planeGeometry, planeMaterial);
	    plane.receiveShadow = true;

	    // rotate and position the plane
	    plane.rotation.y = Math.cos(0.5);
	    plane.position.x = 15;
	    plane.position.y = 15;
	    plane.position.z = -20;

	    // add the plane to the scene
		//scene.add(plane);


        // create a cube
        var cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
        var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000, side: THREE.DoubleSide});
        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.castShadow = true;

	    // position the cube
	    cube.position.x = -4;
	    cube.position.y = 3;
	    cube.position.z = 0;

	    // add the cube to the scene
	    //scene.add(cube);

	        
       	
        
        

        var sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
        var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});
        var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

        // position the sphere
        sphere.position.x = 20;
        sphere.position.y = 0;
        sphere.position.z = 2;
        sphere.castShadow = true;

        // add the sphere to the scene
        //scene.add(sphere);

        var sprite = new THREE.TextureLoader().load('textures/particle.png');
        // create the particle variables
		var particleCount = 2000;
		var particles = new THREE.Geometry();
		var pMaterial = new THREE.PointsMaterial({
		      color: 0xFFFFFF,
		      size: 1,
		      map: sprite,
		      blending: THREE.AdditiveBlending,
		      transparent: true
		    });
		// now create the individual particles
		for (var p = 0; p < particleCount; p++) {

		  // create a particle with random
		  // position values, -250 -> 250
		  var pX = Math.random() * 100 - 50,
		      pY = Math.random() * 100 - 50,
		      pZ = Math.random() * 100 - 50,
		      particle = new THREE.Vector3(pX, pY, pZ);

		  // add it to the geometry
		  particles.vertices.push(particle);
		  var pointLight = new THREE.PointLight(0xffffff, 1, 100);
		  pointLight.position.set(pX, pY, pZ);
		}

		// create the particle system
		var particleSystem = new THREE.Points(
		    particles,
		    pMaterial);

		particleSystem.sortParticles = true;
		// add it to the scene
		particleSystem.position.x = 10;
		particleSystem.position.z = -15;

		scene.add(particleSystem);

		/////////////TEXT////////////////////
		var loader = new THREE.FontLoader();

		loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {

			var geometry = new THREE.TextGeometry( 'FP Grafkom', {
				font: font,
				size: 2,
				height: 0.01,
			} );
			var material = new THREE.MeshBasicMaterial({color: 0xffffff
			})

			var text = new THREE.Mesh(geometry, material);
			text.position.x = -15;
			text.lookAt(camera.position);
			scene.add(text);
		} );
		/////////////TEXT////////////////////

        // add subtle ambient lighting
        var ambientLight = new THREE.AmbientLight(0x0c0c0c);
        scene.add(ambientLight);

        // add spotlight for the shadows
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-40, 60, -10);
        spotLight.castShadow = true;
        scene.add(spotLight);

        // add the output of the renderer to the html element

        // call the render function
        var step = 0;
        renderScene();
        particle.velocity = new THREE.Vector3(0, -Math.random(), 0);

        function renderScene() {
            stats.update();

            var pCount = particleCount;

            while(pCount--)
            {
            	//console.log(particles.vertices[pCount]);
            	if(particles.vertices[pCount].y < -20)
            	{
            		particles.vertices[pCount].y = 20;
            		particles.vertices[pCount].velocity = 0.1;
            	}


            	particles.vertices[pCount].velocity -= Math.random() * 0.1;

            	particles.vertices[pCount].y += Math.random();

            	//particle.velocity.y -= Math.random() * 0.1;

            	//particle.position.add(particle.velocity);
            	particleSystem.geometry.__dirtyVertices = true;

            }

            //console.log(particles.vertices[3]);
            particleSystem.rotation.y += 0.01;
            var kameraUpdate = camera;
            window.onmousemove = function(event)
	        {
	        	var x = event.clientX/window.innerWidth - 0.5;
	        	var y = event.clientY/window.innerHeight - 0.5;
	        	console.log(event);
	        	kameraUpdate.position.x += x;
	        	kameraUpdate.position.y -= y;
	        };
            kameraUpdate.lookAt(0, 0, 0);
            // render using requestAnimationFrame
            renderer.render(scene, kameraUpdate);
            requestAnimationFrame(renderScene);
        }

        function initStats() {

            var stats = new Stats();

            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.getElementById("Stats-output").appendChild(stats.domElement);

            return stats;
        }
    }
    window.onload = init;

</script>
</body>
</html>