<!DOCTYPE html>

<html>

<head>
    <title>Example 01.04 - Materials, light and animation</title>
    <script type="text/javascript" src="../build/three.js"></script>

    <script type="text/javascript" src="./js/libs/stats.min.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    function init() {
    	

        var stats = initStats();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();

        renderer.setClearColor(new THREE.Color(0xffffff));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById("WebGL-output").appendChild(renderer.domElement);

        document.addEventListener('mousedown', onDocumentMouseDown, false);

		// position and point the camera to the center of the scene
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 30;
        camera.lookAt(scene.position);

        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(200, 200, 1, 1);
        var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
       	var plane = new THREE.Mesh(planeGeometry, planeMaterial);
	    plane.receiveShadow = true;

	    // rotate and position the plane
	    plane.rotation.y = Math.cos(0.5);
	    plane.position.x = 15;
	    plane.position.y = 15;
	    plane.position.z = -20;

	    // add the plane to the scene
		//scene.add(plane);    

        var sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
        var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});
        var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

        // position the sphere
        sphere.position.x = 20;
        sphere.position.y = 0;
        sphere.position.z = 2;
        sphere.castShadow = true;

        // add the sphere to the scene
        //scene.add(sphere);

        var sprite = new THREE.TextureLoader().load('textures/sprite.png');
        // create the particle variables
		var particleCount = 2000;
		var particles = new THREE.Geometry();
		var particlesVelocity = []

		var pMaterial = new THREE.PointsMaterial({
		      color: 0x000000,
		      size: 1,
		      map: sprite,
		      blending: THREE.NormalBlending,
		      transparent: true
		    });
		// now create the individual particles
		for (var p = 0; p < particleCount; p++) {

		  // create a particle with random
		  // position values, -50 -> 50
		  var pX = Math.random() * 100 - 50,
		      pY = Math.random() * 100 - 50,
		      pZ = Math.random() * 100 - 50,
		      particle = new THREE.Vector3(pX, pY, pZ);

		  // add it to the geometry
		  particles.vertices.push(particle);

		  var tempVelocity = new THREE.Vector3(0, (Math.random()*100 - 50), 0);
		  particlesVelocity.push(tempVelocity);
		}
		
		// create the particle system
		var particleSystem = new THREE.Points(
		    particles,
		    pMaterial);

		particleSystem.sortParticles = true;
		// add it to the scene
		particleSystem.position.x = 10;
		particleSystem.position.z = -15;
		console.log(particleSystem);
		scene.add(particleSystem);

		/////////////TEXT////////////////////
		var loader = new THREE.FontLoader();

		loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {

			var geometry = new THREE.TextGeometry( 'FP Grafkom', {
				font: font,
				size: 2,
				height: 0.01,
			} );
			var material = new THREE.MeshBasicMaterial({color: 0x000000
			})

			var text = new THREE.Mesh(geometry, material);
			text.position.x = -15;
			text.lookAt(camera.position);
			scene.add(text);
		} );

		loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {

			var geometry = new THREE.TextGeometry( 'New Game', {
				font: font,
				size: 2,
				height: 0.01,
			} );
			var material = new THREE.MeshBasicMaterial({color: 0x000000
			})

			var text = new THREE.Mesh(geometry, material);
			text.position.z = -15;
			text.position.x = 5;
			text.lookAt(camera.position);
			scene.add(text);
		} );

		/////////////TEXT////////////////////

        // add subtle ambient lighting
        var ambientLight = new THREE.AmbientLight(0x0c0c0c);
        scene.add(ambientLight);

        // add spotlight for the shadows
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-40, 60, -10);
        spotLight.castShadow = true;
        scene.add(spotLight);

        // add the output of the renderer to the html element

        // call the render function
        var step = 0;
        renderScene();

        function renderScene() {
            stats.update();

            var pCount = particleCount;

            while(pCount--)
            {
            	//console.log(particles.vertices[pCount]);
            	if(particles.vertices[pCount].y < -20)
            	{
            		particles.vertices[pCount].y = 20;
            		particlesVelocity[pCount].y = 0;
            	}


            	particlesVelocity[pCount].y -= Math.random();

            	particles.vertices[pCount].add(particlesVelocity[pCount]);


            	particleSystem.sortParticles = true;

            	particleSystem.geometry.__dirtyVertices = true;

            }

            //console.log(particles.vertices[3]);
            particleSystem.rotation.y += 0.01;
            window.onmousemove = function(event)
	        {
	        	var x = (event.clientX/window.innerWidth - 0.5)*4;
	        	var y = (event.clientY/window.innerHeight - 0.5)*4;
	        	camera.position.x = 0;
		        camera.position.y = 0;
		        camera.position.z = 30;
	        	camera.position.x += x;
	        	camera.position.y -= y;
	        };
            camera.lookAt(0, 0, 0);

            // render using requestAnimationFrame
            renderer.render(scene, camera);
            requestAnimationFrame(renderScene);
        }


        function onDocumentMouseDown(event) {

            var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);
            vector = vector.unproject(camera);

            var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

            var intersects = raycaster.intersectObjects([sphere, cylinder, cube]);

            if (intersects.length > 0) {

                console.log(intersects[0]);

                intersects[0].object.material.transparent = true;
                intersects[0].object.material.opacity = 0.1;
            }
        }

        function initStats() {

            var stats = new Stats();

            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.getElementById("Stats-output").appendChild(stats.domElement);

            return stats;
        }
    }
    window.onload = init;

</script>
</body>
</html>